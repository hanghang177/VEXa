#pragma config(Motor,  port2,           left1,         tmotorServoContinuousRotation, openLoop, driveLeft)
#pragma config(Motor,  port3,           left2,         tmotorServoContinuousRotation, openLoop, driveLeft)
#pragma config(Motor,  port4,           right1,        tmotorServoContinuousRotation, openLoop, driveRight)
#pragma config(Motor,  port5,           right2,        tmotorServoContinuousRotation, openLoop, driveRight)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include <../inc/Remotecontrol.h>

#define joystickthreshold 15
#define autogoaldisttime 5000
#define turn90time 500

#define raisearmbtn vexRT[Btn5U]
#define intakebtn vexRT[Btn6U]
#define debugautobtn vexRT[Btn7L]

//Config
bool auto = false;
bool mecanum = true;

//Channel
int x1 = 0;
int y1 = 0;
int x2 = 0;
int y2 = 0;

//Last button state
bool lastraisearmbtn = false;
bool lastintakebtn = false;
bool lastdebugautobtn = false;

//Button press
bool raisearmbtnpressed = false;
bool intakebtnpressed = false;
bool debugautobtnpressed = false;

//Speed of each motor
int leftspeed[2];
int rightspeed[2];

//Debug String
string debugger;

void intake()
{

}

void outthrow()
{

}

void raisearm()
{

}

void putdownarm()
{

}

void takecone()
{

}

void releasecone()
{

}

void goforward()
{
	leftspeed[0] = 100;
	leftspeed[1] = 100;
	rightspeed[0] = 100;
	rightspeed[1] = 100;
}

void turn90(bool right)
{
	if(right)
	{
		leftspeed[0] = 100;
		leftspeed[1] = 100;
		rightspeed[0] = -100;
		rightspeed[1] = -100;
	}
	else
	{
		leftspeed[0] = -100;
		leftspeed[1] = -100;
		rightspeed[0] = 100;
		rightspeed[1] = 100;
	}
	go();
	delay(turn90time);
}

void filterRT()	//Filter out noise in vexRT
{
	x1 = vexRT[Ch4];
	y1 = vexRT[Ch3];
	x2 = vexRT[Ch2];
	y2 = vexRT[Ch1];
	if(abs(x1) <= joystickthreshold)
	{
		x1 = 0;
	}
	if(abs(y1) <= joystickthreshold)
	{
		y1 = 0;
	}
	if(abs(x2) <= joystickthreshold)
	{
		x2 = 0;
	}
	if(abs(y2) <= joystickthreshold)
	{
		y2 = 0;
	}
}

void mecanumdrive()	//Using mecanumdrive
{
	leftspeed[0] = y1 + x2 + x1;
	leftspeed[1] = y1 + x2 - x1;
	rightspeed[0] = y1 - x2 - x1;
	rightspeed[1] = y1 - x2 + x1;
}

void skiddrive()	//Using skiddrive
{
	leftspeed[0] = y1 + x2;
	leftspeed[1] = y1 + x2;
	rightspeed[0] = y1 - x2;
	rightspeed[1] = y1 - x2;
}

void debugprint()	//Print debug info to LCD screen
{
	sprintf(debugger, "X1: %d, Y1: %d, X2: %d, Y2: %d", x1, y1, x2, y2);
	displayNextLCDString(debugger);
}

void buttonhandler()
{
	if(lastraisearmbtn){
		if(!raisearmbtn){
			raisearmbtnpressed = true;
		}
	}
	if(lastintakebtn){
		if(!intakebtn){
			intakebtnpressed = true;
		}
	}
	if(lastdebugautobtn){
		if(!debugautobtn){
			debugautobtnpressed = true;
		}
	}
}

void rtControl()
{
	buttonhandler();
	if(raisearmbtnpressed)
	{
		raisearmbtnpressed = false;
	}
	if(intakebtnpressed)
	{
		intakebtnpressed = false;
	}
	if(debugautobtnpressed)
	{
		debugautobtnpressed = false;
		auto = !auto;
	}
	if(mecanum)
	{
		mecanumdrive();
	}
	else
	{
		skiddrive();
	}

}

void go()	//Runs the motor
{
	motor[left1] = leftspeed[0];
	motor[left2] = leftspeed[1];
	motor[right1] = rightspeed[0];
	motor[right2] = rightspeed[1];
}

task main()
{
	while(!auto)
	{
		debugprint();
		filterRT();
		rtControl();
		go();
	}
	while(auto)
	{
		//Auto function
		takecone();
		raisearm();
		goforward();
		delay(autogoaldisttime);
		intake();
		putdownarm();
		releasecone();
		raisearm();
		turn90(1);
		turn90(1);
		goforward();
		delay(autogoaldisttime);
		outthrow();
	}
}
